<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: blade | Tomasz Pluskiewicz]]></title>
  <link href="http://t-code.pl/blog/categories/blade/atom.xml" rel="self"/>
  <link href="http://t-code.pl/"/>
  <updated>2021-03-28T12:28:09+00:00</updated>
  <id>http://t-code.pl/</id>
  <author>
    <name><![CDATA[Tomasz Pluskiewicz]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Emulating Castle Blade's nested transitions with Spark]]></title>
    <link href="http://t-code.pl/blog/2011/10/emulating-castle-blades-nested-transitions-with-spark/"/>
    <updated>2011-10-07T19:44:07-04:00</updated>
    <id>http://t-code.pl/blog/2011/10/emulating-castle-blades-nested-transitions-with-spark</id>
    <content type="html"><![CDATA[<h2 id="nested-transitions">Nested transitions</h2>

<p>As described on <a href="http://hammett.castleproject.org/index.php/category/castle/monorail/">Hammet’s post</a>, Castle Blade view 
engine extends Razor’s syntax to allow nested transitions. Those in turn give Blade a great deal of flexibility. The 
given example being usage of the new FormHelper.</p>

<!--more-->

<p>``` ruby
@Form.For(…, @=&gt; builder {
   builder.FormTemplate(@=&gt; t {
      &lt;div&gt;
         @t.Label(): @t.Field()
      &lt;/div&gt;
   });</p>

<pre><code>&lt;fieldset id="contactForm"&gt;

@builder.TemplateFor( m =&gt; m.Name )
   @builder.TemplateFor( m =&gt; m.Email )
&lt;/fieldset&gt; }) ```
</code></pre>

<p>The above is indeed cool but the readability is not great in my opinion. In Spark the above could look like this:</p>

<p>``` xml</p>
<form for="ViewData.Model" url="UserController.Urls.Update.Post()">
    <FormTemplate>
        <div>
            ${t.Label()} ${t.Field()}
        </div>
    </FormTemplate>

    <fieldset id="contactForm">
        <Template for="Name" />
        <Template for="Email" />
   </fieldset>
</form>
<p>```</p>

<p>Unfortunately porting the syntax of nested transitions to Spark was not exactly easy. My initial solution was to use
<a href="http://sparkviewengine.com/documentation/expressions#DeclaringMacros">macros</a>macros. I wrote about it on <a href="https://groups.google.com/forum/#!topic/spark-dev/-5yRXd2DPIQ">Spark’s discussions group</a>. However this solution was far from
perfect and following Robert’s suggestions I changed the implementation to <a href="http://sparkviewengine.com/documentation/bindings">bindings</a> and helper methods.</p>

<h2 id="nested-tra-what">Nested tra… what?</h2>

<p>Nested transition, or blocks are evaluated as inline lambdas. This means that the some of the XML tags will have to be
evaluated as either a compatible method call or it’s body.</p>

<p>In the above example those custom tags are <code>&lt;Form&gt;</code>, <code>&lt;FormTemplate&gt;</code> and <code>&lt;Template&gt;</code>. They correspond to lines 1, 2,
10 and 11 in the Blade code fragment. The above example transforms into something like the following in C#:</p>

<p>``` c#
Form.For(
   ViewData.Model,
   UserController.Urls.Update.Post(),
   builder =&gt;
      {
         builder.FormTemplate(
            t =&gt;
               new HtmlResult(“rendered content”));</p>

<pre><code>           // some output writing
           builder.TemplateFor(m =&gt; m.Name);
           builder.TemplateFor(m =&gt; m.Email);

           // some output writing
           return new HtmlResult("rendered content");
  } ); ```
</code></pre>

<p>The most important parts are indeed the lambda expressions. The tricky part was transforming Spark’s XML to te above-like
form.</p>

<h2 id="bindings-to-the-rescue">Bindings to the rescue</h2>

<p>For the mentioned transformations needed for this example to work I created 3 transformation. One for each method called \
(ie. <code>Form.For</code>, <code>builder.FormTemplate</code> and <code>builder.TemplateFor</code>):</p>

<p>``` xml</p>
<bindings>
  <element name="form">
    <start># Form.For(@for, @url,
    builder =&gt; new Castle.MonoRail.Helpers.HtmlResult(
      formOutputWriter =&gt; {
      using(OutputScope(formOutputWriter)) {
    </start>
    <end># }}));</end>
  </element>

  <element name="Template">
    builder.TemplateFor( model =&gt; model.@for )
  </element>

  <element name="FormTemplate">
    <start># builder.FormTemplate(
    t =&gt; new Castle.MonoRail.Helpers.HtmlResult(
      formTemplateOutputWriter =&gt; {
        using(OutputScope(formTemplateOutputWriter)) {
    </start>
    <end># }}));</end>
  </element>
</bindings>
<p>```</p>

<p>Bindings transform a nonstandard tag defined by the name attribute into a given form and can take any number of
parameters. It this example <code>&lt;Form&gt;</code> tag, if supplied for and url parameters transforms into a FormHelper#For call, it’s
content rendered as usually by Spark. <FormTemplate> tag being a simmilar case. Any <Template> tag transforms into a
simple GenFormBuilder#TemplateFor call without body, but requires a 'for' parameter, which is the current model's property.</Template></FormTemplate></p>

<h2 id="other-uses">Other uses</h2>

<p>I would assume that those nested transitions will be heavily used in Blade and thus the above method could be used
heavily when working with the new Monorail’s lambda API.</p>

<p>Because of that these and other bindings are stored in an embedded resource and I have created custom IBindingProvider
decorated class, which will combine them with any custom user bindings. This class can be found
<a href="https://github.com/ploosqva/Castle.MonoRail3/blob/master/src/Castle.MonoRail.ViewEngines.Spark/Castle.Monorail.ViewEngines.Spark/Bindings/MR3BindingProvider.cs">here</a>.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spark View Engine for Monorail3]]></title>
    <link href="http://t-code.pl/blog/2011/10/spark-view-engine-for-monorail3/"/>
    <updated>2011-10-07T19:43:11-04:00</updated>
    <id>http://t-code.pl/blog/2011/10/spark-view-engine-for-monorail3</id>
    <content type="html"><![CDATA[<p><a href="http://hammett.castleproject.org">Hamilton Verissimo</a> currently develops a next version of Monorail, which uses a new
view engine called Blade. As much as I’d love to use Monorail 3 in the (near) future, Spark is bound to stay my view
engine of choice.</p>

<!--more-->

<p>Unfortunately Monorail 3 is a complete rewrite in F# and the current Spark won’t work out of the box and a new library
is needed. Thus I forked the <a href="https://github.com/castleproject/Castle.MonoRail">Monorail3 git repository</a> (you can find
it at <a href="https://github.com/ploosqva/Castle.MonoRail3">https://github.com/ploosqva/Castle.MonoRail3</a>, where I will slowly
implement features found in the current Spark for Monorail 2.x.</p>

<p>I will post some notes on the progress on this blog. Below is the list of current posts on that subject:</p>

<ol>
  <li><a href="/2011/10/emulating-castle-blades-nested-transitions-with-spark/">Castle Blade’s nested transitions with Spark</a></li>
</ol>
]]></content>
  </entry>
  
</feed>
